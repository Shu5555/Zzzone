# Zzzone 追加機能ロードマップ v4

## 概要
本ドキュメントでは、Zzzoneアプリに追加する2つの新機能について、実装方針と詳細仕様を記載します。

---

## 追加機能1: 目標入眠時刻達成ボーナス

### 機能概要
ユーザーが設定した目標入眠時刻を達成した場合、自動的にスリープコインを100枚付与する機能です。睡眠習慣の改善をより強力にインセンティブ化します。

### 実装仕様

#### 1.1 達成判定ロジック
- **判定タイミング:** 睡眠記録の保存時（手動記録・自動計測の両方）
- **達成条件:** 
  - ユーザーが目標入眠時刻を設定している
  - 実際の入眠時刻が目標入眠時刻の±15分以内
  - 同じ日付に対して既にボーナスを受け取っていない
- **ボーナス額:** 100 スリープコイン

#### 1.2 クライアントサイドの実装

**必要な変更箇所:**

1. **`lib/models/sleep_record.dart`**
   - `bedtime_goal_achieved` フィールドを追加（bool型、デフォルトfalse）
   - 達成判定メソッド `checkBedtimeGoalAchievement()` を追加

2. **`lib/services/database_helper.dart`**
   - `sleep_records` テーブルに `bedtime_goal_achieved` カラムを追加
   - マイグレーション処理を実装

3. **`lib/services/sleep_record_service.dart`**
   - 睡眠記録保存時に目標達成をチェック
   - 達成時にSupabaseの `award_bedtime_bonus` RPC関数を呼び出し
   - ローカルDBの `bedtime_goal_achieved` フラグを更新

4. **`lib/screens/sleep_input_screen.dart`**
   - 目標達成時にお祝いメッセージとコイン付与通知を表示
   - 「+100コイン獲得！」のようなアニメーション表示（オプション）

#### 1.3 バックエンドの実装

**Supabaseテーブル変更:**

```sql
-- sleep_recordsテーブルにカラム追加
ALTER TABLE public.sleep_records 
ADD COLUMN bedtime_goal_achieved BOOLEAN DEFAULT FALSE;
```

**RPC関数の作成:**

```sql
-- 目標達成ボーナス付与関数
CREATE OR REPLACE FUNCTION award_bedtime_bonus(
  p_user_id UUID,
  p_record_id BIGINT,
  p_bonus_amount INT DEFAULT 100
)
RETURNS TABLE(new_balance INT, awarded BOOLEAN) AS $$
DECLARE
  already_awarded BOOLEAN;
  current_balance INT;
BEGIN
  -- 既に付与済みかチェック
  SELECT bedtime_goal_achieved INTO already_awarded
  FROM public.sleep_records
  WHERE id = p_record_id AND user_id = p_user_id;
  
  IF already_awarded THEN
    SELECT sleep_coins INTO current_balance FROM public.users WHERE id = p_user_id;
    RETURN QUERY SELECT current_balance, FALSE;
    RETURN;
  END IF;
  
  -- コインを付与
  UPDATE public.users
  SET sleep_coins = sleep_coins + p_bonus_amount
  WHERE id = p_user_id
  RETURNING sleep_coins INTO current_balance;
  
  -- 記録に達成フラグを立てる
  UPDATE public.sleep_records
  SET bedtime_goal_achieved = TRUE
  WHERE id = p_record_id AND user_id = p_user_id;
  
  RETURN QUERY SELECT current_balance, TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### 1.4 UI/UX設計

- **達成通知:** ダイアログまたはスナックバーで「目標達成！+100コイン」を表示
- **履歴画面での表示:** 睡眠記録一覧で達成日にバッジ（⭐️や🏆など）を表示
- **統計情報:** プロフィール画面に「目標達成回数」を追加表示

---

## 追加機能2: ギフトコード機能

### 機能概要
管理者が生成したギフトコードをユーザーが入力することで、スリープコインや特別な名言を獲得できる機能です。キャンペーンやプロモーション、ユーザー還元施策として活用できます。

### 実装仕様

#### 2.1 ギフトコードの種類
- **コイン付与型:** 指定された枚数のスリープコインを付与
- **名言付与型:** 特定のレア名言を直接付与（ガチャ不要）
- **背景色付与型:** 特定の背景色を無料でアンロック

#### 2.2 ギフトコードの仕様
- **フォーマット:** `ZZZONE-XXXXX-XXXXX`（例: `ZZZONE-A3B7F-9K2M1`）
- **使用制限:**
  - 1コードあたりの使用回数制限（1回限り、または複数回）
  - 有効期限設定（オプション）
  - ユーザーごとの使用回数制限（1人1回のみ）

#### 2.3 クライアントサイドの実装

**新規画面の追加:**

1. **`lib/screens/gift_code_screen.dart`**
   - ギフトコード入力フィールド
   - 「引き換える」ボタン
   - 引き換え履歴の表示（直近5件など）
   - エラーメッセージ表示（無効なコード、使用済み、期限切れなど）

**必要なサービス:**

2. **`lib/services/gift_code_service.dart`**
   ```dart
   class GiftCodeService {
     // ギフトコードの検証と引き換え
     Future<GiftCodeResult> redeemGiftCode(String userId, String code);
     
     // 引き換え履歴の取得
     Future<List<RedemptionHistory>> getRedemptionHistory(String userId);
   }
   ```

**ナビゲーション:**
- プロフィール画面またはホーム画面に「ギフトコード」ボタンを追加

#### 2.4 バックエンドの実装

**Supabaseテーブル設計:**

```sql
-- ギフトコードテーブル
CREATE TABLE public.gift_codes (
  code TEXT PRIMARY KEY,
  code_type TEXT NOT NULL, -- 'coins', 'quote', 'background'
  reward_value TEXT NOT NULL, -- コイン数、名言ID、背景ID
  max_redemptions INT, -- NULL = 無制限
  current_redemptions INT DEFAULT 0,
  expires_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by TEXT, -- 管理者ID
  description TEXT -- コードの説明（内部用）
);

-- ギフトコード引き換え履歴テーブル
CREATE TABLE public.gift_code_redemptions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  code TEXT NOT NULL REFERENCES public.gift_codes(code) ON DELETE CASCADE,
  redeemed_at TIMESTAMPTZ DEFAULT now(),
  reward_received TEXT NOT NULL, -- 実際に付与された報酬の詳細
  UNIQUE (user_id, code) -- ユーザーごとに1回のみ
);

-- インデックス
CREATE INDEX idx_gift_codes_expires ON public.gift_codes(expires_at);
CREATE INDEX idx_redemptions_user ON public.gift_code_redemptions(user_id);
```

**RPC関数:**

```sql
-- ギフトコード引き換え関数
CREATE OR REPLACE FUNCTION redeem_gift_code(
  p_user_id UUID,
  p_code TEXT
)
RETURNS TABLE(
  success BOOLEAN,
  message TEXT,
  reward_type TEXT,
  reward_value TEXT
) AS $$
DECLARE
  v_code_type TEXT;
  v_reward_value TEXT;
  v_max_redemptions INT;
  v_current_redemptions INT;
  v_expires_at TIMESTAMPTZ;
  v_already_redeemed BOOLEAN;
BEGIN
  -- コードの存在確認
  SELECT code_type, reward_value, max_redemptions, current_redemptions, expires_at
  INTO v_code_type, v_reward_value, v_max_redemptions, v_current_redemptions, v_expires_at
  FROM public.gift_codes
  WHERE code = p_code;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT FALSE, 'invalid_code', NULL::TEXT, NULL::TEXT;
    RETURN;
  END IF;
  
  -- 有効期限チェック
  IF v_expires_at IS NOT NULL AND v_expires_at < now() THEN
    RETURN QUERY SELECT FALSE, 'expired', NULL::TEXT, NULL::TEXT;
    RETURN;
  END IF;
  
  -- 使用回数制限チェック
  IF v_max_redemptions IS NOT NULL AND v_current_redemptions >= v_max_redemptions THEN
    RETURN QUERY SELECT FALSE, 'max_redemptions_reached', NULL::TEXT, NULL::TEXT;
    RETURN;
  END IF;
  
  -- ユーザーの重複使用チェック
  SELECT EXISTS(
    SELECT 1 FROM public.gift_code_redemptions
    WHERE user_id = p_user_id AND code = p_code
  ) INTO v_already_redeemed;
  
  IF v_already_redeemed THEN
    RETURN QUERY SELECT FALSE, 'already_redeemed', NULL::TEXT, NULL::TEXT;
    RETURN;
  END IF;
  
  -- 報酬の付与
  IF v_code_type = 'coins' THEN
    UPDATE public.users
    SET sleep_coins = sleep_coins + v_reward_value::INT
    WHERE id = p_user_id;
  ELSIF v_code_type = 'quote' THEN
    INSERT INTO public.user_unlocked_quotes (user_id, quote_id)
    VALUES (p_user_id, v_reward_value)
    ON CONFLICT (user_id, quote_id) DO NOTHING;
  ELSIF v_code_type = 'background' THEN
    INSERT INTO public.user_unlocked_backgrounds (user_id, background_id)
    VALUES (p_user_id, v_reward_value)
    ON CONFLICT (user_id, background_id) DO NOTHING;
  END IF;
  
  -- 引き換え履歴を記録
  INSERT INTO public.gift_code_redemptions (user_id, code, reward_received)
  VALUES (p_user_id, p_code, v_code_type || ':' || v_reward_value);
  
  -- 使用回数を更新
  UPDATE public.gift_codes
  SET current_redemptions = current_redemptions + 1
  WHERE code = p_code;
  
  RETURN QUERY SELECT TRUE, 'success', v_code_type, v_reward_value;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### 2.5 管理者用ツール（別アプリ）

**概要:**
ギフトコードの生成・管理を行う専用のWebアプリケーションを作成します。

**技術スタック:**
- **フレームワーク:** Flutter Web または React/Next.js
- **認証:** Supabase Auth（管理者専用ログイン）
- **デプロイ:** Vercel / Netlify / Firebase Hosting

**機能要件:**

1. **コード生成画面**
   - コードタイプ選択（コイン/名言/背景色）
   - 報酬値の入力
   - 使用回数制限の設定
   - 有効期限の設定
   - 生成数の指定（一括生成）
   - 説明・メモの入力

2. **コード一覧画面**
   - 生成済みコードの一覧表示
   - フィルタリング（タイプ、有効/期限切れ、使用状況）
   - 使用状況の確認（何人が使用したか）
   - コードの無効化/削除

3. **統計画面**
   - コードタイプ別の使用統計
   - 日別・月別の引き換え数
   - 人気のコード分析

**実装例（Flutter Web）:**

```dart
// lib/admin/screens/code_generator_screen.dart
class CodeGeneratorScreen extends StatefulWidget {
  @override
  _CodeGeneratorScreenState createState() => _CodeGeneratorScreenState();
}

class _CodeGeneratorScreenState extends State<CodeGeneratorScreen> {
  final _formKey = GlobalKey<FormState>();
  String _codeType = 'coins';
  String _rewardValue = '';
  int? _maxRedemptions;
  DateTime? _expiresAt;
  int _generateCount = 1;
  
  Future<void> _generateCodes() async {
    if (!_formKey.currentState!.validate()) return;
    
    final codes = <String>[];
    for (int i = 0; i < _generateCount; i++) {
      codes.add(_generateRandomCode());
    }
    
    // Supabaseに保存
    await _saveToDatabase(codes);
    
    // CSVでエクスポート
    _exportToCsv(codes);
  }
  
  String _generateRandomCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    final random = Random.secure();
    final part1 = List.generate(5, (_) => chars[random.nextInt(chars.length)]).join();
    final part2 = List.generate(5, (_) => chars[random.nextInt(chars.length)]).join();
    return 'ZZZONE-$part1-$part2';
  }
  
  // UI実装...
}
```

**セキュリティ考慮事項:**
- Row Level Security (RLS) で管理者のみアクセス可能に設定
- 管理者テーブルを作成し、許可されたユーザーのみログイン可能
- コード生成時にログを記録

```sql
-- 管理者テーブル
CREATE TABLE public.admins (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id),
  email TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- RLS設定
ALTER TABLE public.gift_codes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "管理者のみ操作可能" ON public.gift_codes
FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM public.admins
    WHERE user_id = auth.uid()
  )
);
```

---

## 実装優先順位

### Phase 1: 目標入眠時刻達成ボーナス（2週間）
1. バックエンドテーブル・RPC関数の実装（3日）
2. クライアントロジックの実装（5日）
3. UI/UX実装とアニメーション（4日）
4. テストとバグ修正（2日）

### Phase 2: ギフトコード機能（3週間）
1. バックエンド設計・実装（5日）
2. 管理者ツールの開発（7日）
3. クライアント側実装（5日）
4. テストとセキュリティ監査（4日）

---

## テスト計画

### 目標入眠時刻達成ボーナス
- [ ] 目標時刻ぴったりで達成判定されるか
- [ ] ±15分の範囲で判定されるか
- [ ] 同じ日に複数回付与されないか
- [ ] オフライン時の記録でも後から付与されるか
- [ ] コイン残高が正しく更新されるか

### ギフトコード機能
- [ ] 有効なコードで正しく報酬が付与されるか
- [ ] 無効なコードでエラーが表示されるか
- [ ] 期限切れコードが使用できないか
- [ ] 使用回数制限が機能するか
- [ ] ユーザーごとの重複使用が防止されるか
- [ ] 管理者ツールで正しくコード生成できるか
- [ ] 一括生成・エクスポートが正しく動作するか

---

## 今後の拡張案

- **連続達成ボーナス:** 目標入眠時刻を連続で達成した場合、ボーナスを増額
- **シーズン限定ギフトコード:** 期間限定の特別な名言や背景色
- **SNSシェアボーナス:** 達成をシェアするとギフトコードがもらえる
- **友達招待システム:** 招待コードで友達を招待すると双方にボーナス

---

## 注意事項

- ギフトコードは推測困難なランダム文字列を使用する
- 大量の不正使用を防ぐため、レート制限を実装する
- 管理者ツールは必ずBasic認証やIP制限で保護する
- ユーザーへのギフトコード配布は公式SNSやメールで行う

---

## 開発者向けメモ

### 環境変数
```
# .env
SUPABASE_URL=your_supabase_url
SUPABASE_ANON_KEY=your_anon_key
ADMIN_SECRET_KEY=your_admin_secret  # 管理者ツール用
```

### マイグレーション順序
1. `bedtime_goal_achieved`カラム追加
2. `gift_codes`テーブル作成
3. `gift_code_redemptions`テーブル作成
4. `admins`テーブル作成
5. RPC関数の作成
6. RLSポリシーの適用
